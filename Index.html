<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Through Line - Daily Word Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        color: #333;
    }

    .container {
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 1200px;
        width: 100%;
        padding: 40px;
        position: relative;
    }

    header {
        text-align: center;
        margin-bottom: 40px;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 20px;
    }

    h1 {
        font-size: 2.5rem;
        color: #1e3c72;
        font-weight: 300;
        letter-spacing: 2px;
        margin-bottom: 8px;
    }

    .tagline {
        color: #666;
        font-size: 0.95rem;
        font-weight: 300;
        letter-spacing: 1px;
    }

    .date {
        color: #999;
        font-size: 0.85rem;
        margin-top: 8px;
        font-weight: 400;
    }

    .instructions {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 30px;
        border-left: 4px solid #2a5298;
    }

    .instructions p {
        color: #555;
        font-size: 0.95rem;
        line-height: 1.6;
    }

    .through-lines-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    .through-line {
        background: #fff;
        border: 2px solid #e0e0e0;
        border-radius: 12px;
        padding: 16px;
        transition: all 0.3s ease;
    }

    .through-line.solved {
        border-color: #4CAF50;
        background: linear-gradient(135deg, #f1f8f4 0%, #f8fef9 100%);
    }

    .through-line-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
    }

    .through-line-title {
        font-size: 0.8rem;
        font-weight: 600;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .through-line-status {
        font-size: 1.1rem;
    }

    .answer-display {
        text-align: center;
        padding: 10px;
        background: #2a5298;
        color: white;
        border-radius: 8px;
        font-size: 1.1rem;
        font-weight: 600;
        letter-spacing: 2px;
        margin-bottom: 12px;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .answer-display.show {
        opacity: 1;
    }

    .phrase-reveal {
        background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
        color: white;
        padding: 30px;
        border-radius: 12px;
        text-align: center;
        margin: 30px 0;
        display: none;
    }

    .phrase-reveal.show {
        display: block;
        animation: fadeInScale 0.5s ease;
    }

    .phrase-reveal h2 {
        font-size: 1.2rem;
        font-weight: 400;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 15px;
        opacity: 0.9;
    }

    .phrase-text {
        font-size: 2.2rem;
        font-weight: 300;
        letter-spacing: 3px;
        margin: 20px 0;
        line-height: 1.4;
    }

    .phrase-subtext {
        font-size: 0.95rem;
        opacity: 0.8;
        margin-top: 15px;
    }

    .input-section {
        margin-bottom: 30px;
    }

    .input-wrapper {
        position: relative;
        margin-bottom: 15px;
    }

    input[type="text"] {
        width: 100%;
        padding: 12px 16px;
        font-size: 0.95rem;
        border: 2px solid #ddd;
        border-radius: 8px;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 500;
    }

    input[type="text"]:focus {
        outline: none;
        border-color: #2a5298;
        box-shadow: 0 0 0 3px rgba(42, 82, 152, 0.1);
    }

    .submit-btn {
        width: 100%;
        padding: 12px;
        background: #2a5298;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        letter-spacing: 1px;
        text-transform: uppercase;
    }

    .submit-btn:hover {
        background: #1e3c72;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(42, 82, 152, 0.3);
    }

    .submit-btn:active {
        transform: translateY(0);
    }

    .submit-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
    }

    .words-grid {
        display: grid;
        gap: 8px;
        margin-bottom: 16px;
    }

    .word-item {
        background: #f8f9fa;
        padding: 12px 16px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.4s ease;
        border: 2px solid transparent;
        position: relative;
        overflow: hidden;
    }

    .word-number {
        font-size: 0.75rem;
        color: #999;
        font-weight: 600;
        min-width: 24px;
    }

    .word-text {
        font-size: 1rem;
        font-weight: 500;
        color: #333;
        letter-spacing: 1px;
        flex-grow: 1;
        text-align: center;
    }

    .word-connection {
        font-size: 0.75rem;
        color: #2a5298;
        font-weight: 500;
        opacity: 0;
        min-width: 100px;
        text-align: right;
        transition: opacity 0.4s ease;
    }

    .word-item.revealed {
        background: linear-gradient(135deg, #e8f0fe 0%, #f0f4ff 100%);
        border-color: #2a5298;
    }

    .word-item.revealed .word-connection {
        opacity: 1;
    }

    .feedback {
        text-align: center;
        padding: 16px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.3s ease;
        font-size: 1rem;
    }

    .feedback.show {
        opacity: 1;
    }

    .feedback.error {
        background: #fee;
        color: #c33;
        border: 1px solid #fcc;
    }

    .feedback.success {
        background: #efe;
        color: #3a3;
        border: 1px solid #cfc;
    }

    .stats {
        display: flex;
        justify-content: space-around;
        margin-top: 30px;
        padding-top: 30px;
        border-top: 2px solid #e0e0e0;
    }

    .stat-item {
        text-align: center;
    }

    .stat-value {
        font-size: 2rem;
        font-weight: 600;
        color: #2a5298;
        display: block;
    }

    .stat-label {
        font-size: 0.85rem;
        color: #666;
        margin-top: 4px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }



    @keyframes fadeInScale {
        from {
            opacity: 0;
            transform: scale(0.9);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    .word-item.revealed .word-connection {
        animation: slideInRight 0.4s ease;
    }

    @media (max-width: 600px) {
        .container {
            padding: 30px 20px;
        }

        h1 {
            font-size: 2rem;
        }

        .word-text {
            font-size: 1.1rem;
        }

        .word-connection {
            font-size: 0.8rem;
            min-width: 100px;
        }
    }


</style>
```

</head>
<body>
    <div class="container">
        <header>
            <h1>THROUGH LINE</h1>
            <div class="tagline">Find the connecting word</div>
            <div class="date" id="current-date"></div>
        </header>

```
    <div class="instructions">
        <p>Each set of words below needs one connecting word that forms a phrase or compound with all of them. Once you solve all the through lines, the answers will form a common phrase—but they're scrambled!</p>
    </div>

    <div class="feedback" id="feedback"></div>

    <div class="through-lines-container" id="through-lines-container"></div>

    <div class="phrase-reveal" id="phrase-reveal">
        <h2>The Hidden Phrase</h2>
        <div class="phrase-text" id="phrase-text"></div>
        <div class="phrase-subtext">Congratulations! You've discovered the connection.</div>
    </div>

    <div class="stats">
        <div class="stat-item">
            <span class="stat-value" id="attempts-stat">0</span>
            <span class="stat-label">Total Attempts</span>
        </div>
        <div class="stat-item">
            <span class="stat-value" id="solved-stat">0/0</span>
            <span class="stat-label">Solved</span>
        </div>
    </div>
</div>

<script>
    // Game data - each game has multiple through lines whose answers form a phrase
    const games = [
        {
            phrase: "EVERY CLOUD HAS A SILVER LINING",
            throughLines: [
                {
                    words: ['WHERE', 'BODY', 'DAY', 'THING', 'ONE'],
                    answer: 'EVERY',
                    connections: ['EVERYWHERE', 'EVERYBODY', 'EVERYDAY', 'EVERYTHING', 'EVERYONE']
                },
                {
                    words: ['NINE', 'STORAGE', 'COMPUTING', 'COVER', 'FOREST'],
                    answer: 'CLOUD',
                    connections: ['CLOUD NINE', 'CLOUD STORAGE', 'CLOUD COMPUTING', 'CLOUD COVER', 'CLOUD FOREST']
                },
                {
                    words: ['BEEN', 'BROWNS', 'TAG', 'ANYONE', 'SEEN'],
                    answer: 'HAS',
                    connections: ['HAS BEEN', 'HASH BROWNS', 'HASH TAG', 'HAS ANYONE', 'HAS SEEN']
                },
                {
                    words: ['SPOON', 'SCREEN', 'BULLET', 'LINING', 'MEDAL'],
                    answer: 'SILVER',
                    connections: ['SILVER SPOON', 'SILVER SCREEN', 'SILVER BULLET', 'SILVER LINING', 'SILVER MEDAL']
                },
                {
                    words: ['UP', 'DANCE', 'ITEM', 'BACKER', 'DRIVE'],
                    answer: 'LINE',
                    connections: ['LINE UP', 'LINE DANCE', 'LINE ITEM', 'LINE BACKER', 'LINE DRIVE']
                }
            ]
        },
        {
            phrase: "TIME FLIES WHEN HAVING FUN",
            throughLines: [
                {
                    words: ['KEEPER', 'ZONE', 'BOMB', 'PIECE', 'SHARE'],
                    answer: 'TIME',
                    connections: ['TIMEKEEPER', 'TIME ZONE', 'TIME BOMB', 'TIMEPIECE', 'TIMESHARE']
                },
                {
                    words: ['BALL', 'PAPER', 'SWATTER', 'WHEEL', 'FISHING'],
                    answer: 'FLY',
                    connections: ['FLY BALL', 'FLY PAPER', 'FLY SWATTER', 'FLY WHEEL', 'FLY FISHING']
                },
                {
                    words: ['EVER', 'HARRY', 'MET', 'SALLY', 'NEEDED'],
                    answer: 'WHEN',
                    connections: ['WHENEVER', 'WHEN HARRY', 'WHEN MET', 'WHEN SALLY', 'WHEN NEEDED']
                },
                {
                    words: ['FUN', 'DINNER', 'TROUBLE', 'SECOND', 'THOUGHTS'],
                    answer: 'HAVING',
                    connections: ['HAVING FUN', 'HAVING DINNER', 'HAVING TROUBLE', 'HAVING SECOND', 'HAVING THOUGHTS']
                }
            ]
        },
        {
            phrase: "BREAK THE ICE",
            throughLines: [
                {
                    words: ['FAST', 'THROUGH', 'DOWN', 'EVEN', 'NECK'],
                    answer: 'BREAK',
                    connections: ['BREAKFAST', 'BREAKTHROUGH', 'BREAKDOWN', 'BREAK EVEN', 'BREAKNECK']
                },
                {
                    words: ['END', 'BEGINNING', 'BEST', 'WORST', 'REASON'],
                    answer: 'THE',
                    connections: ['THE END', 'THE BEGINNING', 'THE BEST', 'THE WORST', 'THE REASON']
                },
                {
                    words: ['CREAM', 'HOCKEY', 'CUBE', 'BREAKER', 'AGE'],
                    answer: 'ICE',
                    connections: ['ICE CREAM', 'ICE HOCKEY', 'ICE CUBE', 'ICEBREAKER', 'ICE AGE']
                }
            ]
        },
        {
            phrase: "HOME SWEET HOME",
            throughLines: [
                {
                    words: ['WORK', 'TOWN', 'MADE', 'COMING', 'RUN'],
                    answer: 'HOME',
                    connections: ['HOMEWORK', 'HOMETOWN', 'HOMEMADE', 'HOMECOMING', 'HOME RUN']
                },
                {
                    words: ['SIXTEEN', 'TOOTH', 'HEART', 'DREAMS', 'SPOT'],
                    answer: 'SWEET',
                    connections: ['SWEET SIXTEEN', 'SWEET TOOTH', 'SWEETHEART', 'SWEET DREAMS', 'SWEET SPOT']
                }
            ]
        },
        {
            phrase: "ONCE IN A BLUE MOON",
            throughLines: [
                {
                    words: ['UPON', 'MORE', 'AGAIN', 'OVER', 'BITTEN'],
                    answer: 'ONCE',
                    connections: ['ONCE UPON', 'ONCE MORE', 'ONCE AGAIN', 'ONCE OVER', 'ONCE BITTEN']
                },
                {
                    words: ['CROWD', 'LOVE', 'TRANSIT', 'TOUCH', 'FLUX'],
                    answer: 'IN',
                    connections: ['IN CROWD', 'IN LOVE', 'IN TRANSIT', 'IN TOUCH', 'IN FLUX']
                },
                {
                    words: ['MINOR', 'MAJOR', 'FLAT', 'SHARP', 'TEAM'],
                    answer: 'A',
                    connections: ['A MINOR', 'A MAJOR', 'A FLAT', 'A SHARP', 'A TEAM']
                },
                {
                    words: ['COLLAR', 'RIBBON', 'SCREEN', 'BLOOD', 'CHIP'],
                    answer: 'BLUE',
                    connections: ['BLUE COLLAR', 'BLUE RIBBON', 'BLUE SCREEN', 'BLUE BLOOD', 'BLUE CHIP']
                },
                {
                    words: ['LIGHT', 'WALK', 'SHINE', 'BEAM', 'LANDING'],
                    answer: 'MOON',
                    connections: ['MOONLIGHT', 'MOONWALK', 'MOONSHINE', 'MOON BEAM', 'MOON LANDING']
                }
            ]
        }
    ];

    // Get game for today
    function getTodaysGame() {
        const today = new Date();
        const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 86400000);
        const gameIndex = dayOfYear % games.length;
        return games[gameIndex];
    }

    // Game state
    let currentGame = getTodaysGame();
    let totalAttempts = 0;
    let solvedCount = 0;
    let throughLineStates = currentGame.throughLines.map(() => ({
        solved: false,
        attempts: 0
    }));

    // DOM elements
    const throughLinesContainer = document.getElementById('through-lines-container');
    const feedback = document.getElementById('feedback');
    const phraseReveal = document.getElementById('phrase-reveal');
    const phraseText = document.getElementById('phrase-text');
    const attemptsStat = document.getElementById('attempts-stat');
    const solvedStat = document.getElementById('solved-stat');
    const currentDate = document.getElementById('current-date');

    // Initialize game
    function init() {
        // Set date
        const today = new Date();
        const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        currentDate.textContent = today.toLocaleDateString('en-US', options);

        // Render through lines
        renderThroughLines();

        // Update stats
        updateStats();
    }

    function renderThroughLines() {
        throughLinesContainer.innerHTML = '';
        
        currentGame.throughLines.forEach((throughLine, index) => {
            const container = document.createElement('div');
            container.className = 'through-line';
            container.id = `through-line-${index}`;
            
            container.innerHTML = `
                <div class="through-line-header">
                    <span class="through-line-title">Through Line ${index + 1}</span>
                    <span class="through-line-status"></span>
                </div>
                <div class="answer-display" id="answer-${index}"></div>
                <div class="words-grid" id="words-${index}"></div>
                <div class="input-section">
                    <div class="input-wrapper">
                        <input 
                            type="text" 
                            id="input-${index}" 
                            class="through-line-input"
                            placeholder="Type connecting word..."
                            autocomplete="off"
                            maxlength="20"
                            data-index="${index}"
                        >
                    </div>
                </div>
            `;
            
            throughLinesContainer.appendChild(container);
            
            // Render words for this through line
            renderWords(index, throughLine.words);
            
            // Add event listener for dynamic checking
            const input = document.getElementById(`input-${index}`);
            
            input.addEventListener('input', (e) => {
                handleInput(index, e.target.value);
            });
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !throughLineStates[index].solved) {
                    handleSubmit(index);
                }
            });
        });

        // Focus first unsolved input
        const firstUnsolvedIndex = throughLineStates.findIndex(state => !state.solved);
        if (firstUnsolvedIndex !== -1) {
            document.getElementById(`input-${firstUnsolvedIndex}`).focus();
        }
    }

    function renderWords(throughLineIndex, words) {
        const wordsGrid = document.getElementById(`words-${throughLineIndex}`);
        wordsGrid.innerHTML = '';
        
        words.forEach((word, wordIndex) => {
            const wordItem = document.createElement('div');
            wordItem.className = 'word-item';
            wordItem.innerHTML = `
                <span class="word-number">${wordIndex + 1}</span>
                <span class="word-text">${word}</span>
                <span class="word-connection"></span>
            `;
            wordsGrid.appendChild(wordItem);
        });
    }

    function handleInput(index, value) {
        if (throughLineStates[index].solved) return;

        const guess = value.trim().toUpperCase();
        const correctAnswer = currentGame.throughLines[index].answer.toUpperCase();

        // Check if the answer is correct
        if (guess === correctAnswer) {
            handleCorrectAnswer(index);
        }
    }

    function handleSubmit(index) {
        if (throughLineStates[index].solved) return;

        const input = document.getElementById(`input-${index}`);
        const guess = input.value.trim().toUpperCase();
        
        if (!guess) {
            showFeedback('Please enter a word', 'error');
            return;
        }

        totalAttempts++;
        throughLineStates[index].attempts++;
        updateStats();

        const correctAnswer = currentGame.throughLines[index].answer.toUpperCase();

        if (guess === correctAnswer) {
            handleCorrectAnswer(index);
        } else {
            showFeedback('Not the right connection. Try again!', 'error');
            input.value = '';
            input.focus();
        }
    }

    function handleCorrectAnswer(index) {
        throughLineStates[index].solved = true;
        solvedCount++;
        updateStats();

        const throughLine = currentGame.throughLines[index];
        const container = document.getElementById(`through-line-${index}`);
        const answerDisplay = document.getElementById(`answer-${index}`);
        const statusIcon = container.querySelector('.through-line-status');
        
        // Update container
        container.classList.add('solved');
        statusIcon.textContent = '✓';
        
        // Show answer
        answerDisplay.textContent = throughLine.answer.toUpperCase();
        answerDisplay.classList.add('show');
        
        // Hide input section
        const inputSection = container.querySelector('.input-section');
        inputSection.style.display = 'none';
        
        // Reveal connections with animation
        const wordItems = container.querySelectorAll('.word-item');
        wordItems.forEach((item, wordIndex) => {
            setTimeout(() => {
                item.classList.add('revealed');
                const connectionSpan = item.querySelector('.word-connection');
                connectionSpan.textContent = throughLine.connections[wordIndex];
            }, wordIndex * 100);
        });

        showFeedback('Correct! Through line solved!', 'success');

        // Check if all solved
        if (solvedCount === currentGame.throughLines.length) {
            setTimeout(() => {
                revealPhrase();
            }, 1000);
        } else {
            // Focus next unsolved
            setTimeout(() => {
                const nextIndex = throughLineStates.findIndex(state => !state.solved);
                if (nextIndex !== -1) {
                    document.getElementById(`input-${nextIndex}`).focus();
                }
            }, 500);
        }
    }

    function revealPhrase() {
        phraseText.textContent = currentGame.phrase;
        phraseReveal.classList.add('show');
        
        // Scroll to phrase
        setTimeout(() => {
            phraseReveal.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
    }

    function updateStats() {
        attemptsStat.textContent = totalAttempts;
        solvedStat.textContent = `${solvedCount}/${currentGame.throughLines.length}`;
    }

    function showFeedback(message, type) {
        feedback.textContent = message;
        feedback.className = `feedback ${type} show`;
        
        setTimeout(() => {
            feedback.classList.remove('show');
        }, 2500);
    }

    // Initialize on load
    init();
</script>
```

</body>
</html>
